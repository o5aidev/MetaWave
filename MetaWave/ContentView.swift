//
//  ContentView.swift
//  MetaWave
//
//  Created by Ê∏°ÈÉ®‰∏ÄÁîü on 2025/10/21.
//

import SwiftUI
import CoreData
import Speech
import AVFoundation
import Foundation

struct ContentView: View {
    @Environment(\.managedObjectContext) private var viewContext
    @StateObject private var onboardingManager = OnboardingManager()
    @State private var selectedTab = 1
    @State private var analysisSelection: AnalysisSection = .overview
    
    init() {
        // „Éï„Çß„ÉÉ„ÉÅ„Éê„ÉÉ„ÉÅ„Çµ„Ç§„Ç∫„ÅØÂà•ÈÄîË®≠ÂÆö
    }

    var body: some View {
        TabView(selection: $selectedTab) {
            // Notes Tab
            NotesView(onVoiceNoteAdd: addVoiceNote)
            .tabItem {
                Image(systemName: "note.text")
                Text("Notes")
            }
            .tag(0)
            
            // Analysis Tab
            NavigationView {
                VStack(spacing: 16) {
                    Picker("ÂàÜÊûê„Éì„É•„Éº", selection: $analysisSelection) {
                        Text("Ê¶ÇË¶Å").tag(AnalysisSection.overview)
                        Text("„Éë„Çø„Éº„É≥").tag(AnalysisSection.patterns)
                        Text("‰∫àÊ∏¨").tag(AnalysisSection.predictions)
                    }
                    .pickerStyle(.segmented)
                    .padding(.horizontal)
                    
                    Group {
                        switch analysisSelection {
                        case .overview:
                            InsightCardsView()
                        case .patterns:
                            PatternAnalysisView(context: viewContext)
                        case .predictions:
                            PredictionView(context: viewContext)
                        }
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                }
                .padding(.top, 16)
                .navigationTitle("ÂàÜÊûê")
            }
            .tabItem {
                Image(systemName: "brain.head.profile")
                Text("ÂàÜÊûê")
            }
            .tag(1)
            
            // Settings Tab
            NavigationView {
                SettingsView()
            }
            .tabItem {
                Image(systemName: "gear")
                Text("Settings")
            }
            .tag(2)
        }
        .fullScreenCover(isPresented: $onboardingManager.shouldShowOnboarding) {
            OnboardingView()
        }
        .errorHandling {
            // „Ç®„É©„ÉºÊôÇ„ÅÆÂÜçË©¶Ë°åÂá¶ÁêÜ
            print("„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇÂÜçË©¶Ë°å„Åó„Åæ„Åô„ÄÇ")
        }
    }

    // MARK: - Actions
    
    /// Èü≥Â£∞ÂÖ•Âäõ„Åß„Éé„Éº„Éà„ÇíËøΩÂä†
    private func addVoiceNote(text: String) {
        withAnimation {
            let newItem = Item(context: viewContext)
            newItem.timestamp = Date()
            newItem.title = "Èü≥Â£∞„Éé„Éº„Éà"
            newItem.note = text
            
            do {
                try viewContext.save()
                
                // Èü≥Â£∞ÊÑüÊÉÖÂàÜÊûê„ÅÆÂÆüË°åÔºàÈùûÂêåÊúüÔºâ
                Task {
                    await analyzeVoiceEmotion(for: newItem)
                }
            } catch {
                print("[CoreData] Voice note save error:", error.localizedDescription)
            }
        }
    }
    
    // MARK: - Èü≥Â£∞ÊÑüÊÉÖÂàÜÊûê
    private func analyzeVoiceEmotion(for item: Item) async {
        // „ÉÜ„Ç≠„Çπ„ÉàÂÜÖÂÆπ„ÇíÂèñÂæó
        guard let note = item.note, !note.isEmpty else {
            print("‚ö†Ô∏è „Éé„Éº„Éà„ÅåÁ©∫„Åß„Åô")
            return
        }
        
        print("Èü≥Â£∞ÊÑüÊÉÖÂàÜÊûê„ÇíÂÆüË°å: \(note)")
        
        // Á∞°ÊòìÁöÑ„Å™ÊÑüÊÉÖÂàÜÊûê„ÇíÂÆüË°å
        let valence = calculateSimpleValence(text: note)
        let arousal = calculateSimpleArousal(text: note)
        
        print("‚úÖ ÊÑüÊÉÖÂàÜÊûêÂÆå‰∫Ü: valence=\(valence), arousal=\(arousal)")
        
        // ÊÑüÊÉÖ„ÅÆËß£Èáà
        let emotionLabel = interpretEmotion(valence: valence, arousal: arousal)
        print("üìä ÊÑüÊÉÖÁä∂ÊÖã: \(emotionLabel)")
    }
    
    // MARK: - Á∞°ÊòìÊÑüÊÉÖÂàÜÊûê
    private func calculateSimpleValence(text: String) -> Float {
        let positiveWords = ["Ê•Ω„Åó„ÅÑ", "Â¨â„Åó„ÅÑ", "Âπ∏„Åõ", "ËâØ„ÅÑ", "Â•Ω„Åç", "ÊúÄÈ´ò", "Á¥†Êô¥„Çâ„Åó„ÅÑ", "ËâØ„ÅÑ", "great", "good", "happy", "love"]
        let negativeWords = ["ÊÇ≤„Åó„ÅÑ", "Ëæõ„ÅÑ", "Ëã¶„Åó„ÅÑ", "Â´å„ÅÑ", "ÊÇ™„ÅÑ", "ÊúÄÊÇ™", "„ÉÄ„É°", "bad", "sad", "hate", "angry"]
        
        let lowerText = text.lowercased()
        var positiveCount = 0
        var negativeCount = 0
        
        for word in positiveWords {
            if lowerText.contains(word) {
                positiveCount += 1
            }
        }
        
        for word in negativeWords {
            if lowerText.contains(word) {
                negativeCount += 1
            }
        }
        
        let total = positiveCount + negativeCount
        if total == 0 {
            return 0.0
        }
        
        return Float(positiveCount - negativeCount) / Float(total)
    }
    
    private func calculateSimpleArousal(text: String) -> Float {
        let highArousalWords = ["ËààÂ•Æ", "„ÉØ„ÇØ„ÉØ„ÇØ", "„Éâ„Ç≠„Éâ„Ç≠", "È©ö„ÅÑ„Åü", "È©ö„Åç", "excited", "thrilled", "wow", "amazing"]
        let lowArousalWords = ["Áñ≤„Çå„Åü", "Áú†„ÅÑ", "Á©è„ÇÑ„Åã", "Èùô„Åã", "tired", "sleepy", "calm"]
        
        let lowerText = text.lowercased()
        var highCount = 0
        var lowCount = 0
        
        for word in highArousalWords {
            if lowerText.contains(word) {
                highCount += 1
            }
        }
        
        for word in lowArousalWords {
            if lowerText.contains(word) {
                lowCount += 1
            }
        }
        
        let total = highCount + lowCount
        if total == 0 {
            return 0.5 // „Éá„Éï„Ç©„É´„Éà„ÅØ‰∏≠Èñì
        }
        
        return Float(highCount) / Float(total)
    }
    
    private func interpretEmotion(valence: Float, arousal: Float) -> String {
        if valence > 0.3 && arousal > 0.6 {
            return "ËààÂ•ÆÔºàÈ´ò„Éù„Ç∏„ÉÜ„Ç£„ÉñÔºâ"
        } else if valence > 0.3 && arousal < 0.4 {
            return "Á©è„ÇÑ„ÅãÔºà„Éù„Ç∏„ÉÜ„Ç£„ÉñÔºâ"
        } else if valence < -0.3 && arousal > 0.6 {
            return "„Ç§„É©„Ç§„É©ÔºàÈ´ò„Éç„Ç¨„ÉÜ„Ç£„ÉñÔºâ"
        } else if valence < -0.3 && arousal < 0.4 {
            return "ËêΩ„Å°Ëæº„ÅøÔºà„Éç„Ç¨„ÉÜ„Ç£„ÉñÔºâ"
        } else if arousal > 0.6 {
            return "È´òË¶öÈÜíÔºà‰∏≠ÊÄßÔºâ"
        } else {
            return "ÂÆâÂÆöÔºà‰∏≠ÊÄßÔºâ"
        }
    }
}

private enum AnalysisSection: Hashable {
    case overview
    case patterns
    case predictions
}

// MARK: - Simple Voice Input View

struct SimpleVoiceInputView: View {
    let onComplete: (String) -> Void
    @Environment(\.dismiss) private var dismiss
    @State private var inputText = ""
    
    var body: some View {
        NavigationView {
            VStack(spacing: 24) {
                // „Éò„ÉÉ„ÉÄ„Éº
                VStack(spacing: 8) {
                    Image(systemName: "mic.fill")
                        .font(.system(size: 60))
                        .foregroundColor(.blue)
                    
                    Text("Èü≥Â£∞ÂÖ•Âäõ")
                        .font(.title2)
                        .fontWeight(.semibold)
                    
                    Text("„ÉÜ„Ç≠„Çπ„Éà„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                }
                .padding(.top, 20)
                
                // „ÉÜ„Ç≠„Çπ„ÉàÂÖ•Âäõ
                VStack(alignment: .leading, spacing: 12) {
                    Text("„Éé„Éº„ÉàÂÜÖÂÆπ")
                        .font(.headline)
                    
                    TextEditor(text: $inputText)
                        .frame(minHeight: 200)
                        .padding()
                        .background(Color(.systemGray6))
                        .cornerRadius(8)
                }
                
                Spacer()
                
                // „Ç¢„ÇØ„Ç∑„Éß„É≥„Éú„Çø„É≥
                HStack(spacing: 16) {
                    Button("„Ç≠„É£„É≥„Çª„É´") {
                        dismiss()
                    }
                    .buttonStyle(.bordered)
                    .controlSize(.large)
                    
                    Button("‰øùÂ≠ò") {
                        onComplete(inputText)
                        dismiss()
                    }
                    .buttonStyle(.borderedProminent)
                    .controlSize(.large)
                    .disabled(inputText.isEmpty)
                }
                .padding(.bottom, 20)
            }
            .padding()
            .navigationTitle("Èü≥Â£∞ÂÖ•Âäõ")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Èñâ„Åò„Çã") {
                        dismiss()
                    }
                }
            }
        }
    }
}

// MARK: - Insights View

struct InsightsView: View {
    @Environment(\.managedObjectContext) private var viewContext
    @FetchRequest(
        sortDescriptors: [NSSortDescriptor(keyPath: \Item.timestamp, ascending: false)],
        animation: .default
    )
    private var items: FetchedResults<Item>
    
    @State private var emotionAnalysis: [String: Double] = [:]
    @State private var loopDetection: [String] = []
    @State private var biasSignals: [String] = []
    @State private var isLoading = false
    
    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                // „Éò„ÉÉ„ÉÄ„Éº
                VStack(spacing: 8) {
                    Image(systemName: "brain.head.profile")
                        .font(.system(size: 60))
                        .foregroundColor(.blue)
                    
                    Text("„É°„ÇøË™çÁü•ÂàÜÊûê")
                        .font(.title2)
                        .fontWeight(.semibold)
                    
                    Text("ÊÄùËÄÉ„Éë„Çø„Éº„É≥„ÅÆÂàÜÊûêÁµêÊûú")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                .padding(.top, 20)
                
                // ÂàÜÊûê„Éú„Çø„É≥
                Button(action: performAnalysis) {
                    HStack {
                        if isLoading {
                            ProgressView()
                                .scaleEffect(0.8)
                        } else {
                            Image(systemName: "brain")
                        }
                        Text(isLoading ? "ÂàÜÊûê‰∏≠..." : "ÂàÜÊûê„ÇíÂÆüË°å")
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(10)
                }
                .disabled(isLoading || items.isEmpty)
                .padding(.horizontal)
                
                // ÂàÜÊûêÁµêÊûú
                if !emotionAnalysis.isEmpty || !loopDetection.isEmpty || !biasSignals.isEmpty {
                    VStack(spacing: 16) {
                        // ÊÑüÊÉÖÂàÜÊûêÁµêÊûú
                        if !emotionAnalysis.isEmpty {
                            AnalysisCard(
                                title: "ÊÑüÊÉÖÂàÜÊûê",
                                icon: "heart.fill",
                                color: .red
                            ) {
                                VStack(alignment: .leading, spacing: 8) {
                                    ForEach(Array(emotionAnalysis.keys.sorted()), id: \.self) { emotion in
                                        HStack {
                                            Text(emotion)
                                                .font(.subheadline)
                                            Spacer()
                                            Text(String(format: "%.1f%%", emotionAnalysis[emotion]! * 100))
                                                .font(.subheadline)
                                                .fontWeight(.semibold)
                                        }
                                        ProgressView(value: emotionAnalysis[emotion]!)
                                            .progressViewStyle(LinearProgressViewStyle(tint: .red))
                                    }
                                }
                            }
                        }
                        
                        // „É´„Éº„ÉóÊ§úÂá∫ÁµêÊûú
                        if !loopDetection.isEmpty {
                            AnalysisCard(
                                title: "ÊÄùËÄÉ„É´„Éº„ÉóÊ§úÂá∫",
                                icon: "arrow.clockwise",
                                color: .orange
                            ) {
                                VStack(alignment: .leading, spacing: 8) {
                                    ForEach(loopDetection, id: \.self) { loop in
                                        HStack {
                                            Image(systemName: "exclamationmark.triangle.fill")
                                                .foregroundColor(.orange)
                                            Text(loop)
                                                .font(.subheadline)
                                            Spacer()
                                        }
                                        .padding(.vertical, 4)
                                    }
                                }
                            }
                        }
                        
                        // „Éê„Ç§„Ç¢„ÇπÊ§úÂá∫ÁµêÊûú
                        if !biasSignals.isEmpty {
                            AnalysisCard(
                                title: "Ë™çÁü•„Éê„Ç§„Ç¢„ÇπÊ§úÂá∫",
                                icon: "eye.trianglebadge.exclamationmark",
                                color: .purple
                            ) {
                                VStack(alignment: .leading, spacing: 8) {
                                    ForEach(biasSignals, id: \.self) { bias in
                                        HStack {
                                            Image(systemName: "exclamationmark.triangle.fill")
                                                .foregroundColor(.purple)
                                            Text(bias)
                                                .font(.subheadline)
                                            Spacer()
                                        }
                                        .padding(.vertical, 4)
                                    }
                                }
                            }
                        }
                    }
                    .padding(.horizontal)
                } else if !isLoading && !items.isEmpty {
                    // ÂàÜÊûêÁµêÊûú„Åå„Å™„ÅÑÂ†¥Âêà
                    VStack(spacing: 12) {
                        Image(systemName: "chart.bar.xaxis")
                            .font(.system(size: 40))
                            .foregroundColor(.gray)
                        
                        Text("ÂàÜÊûêÁµêÊûú„Åå„ÅÇ„Çä„Åæ„Åõ„Çì")
                            .font(.headline)
                            .foregroundColor(.secondary)
                        
                        Text("„ÄåÂàÜÊûê„ÇíÂÆüË°å„Äç„Éú„Çø„É≥„Çí„Çø„ÉÉ„Éó„Åó„Å¶ÂàÜÊûê„ÇíÈñãÂßã„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .multilineTextAlignment(.center)
                    }
                    .padding(.vertical, 40)
                } else if items.isEmpty {
                    // „Éé„Éº„Éà„Åå„Å™„ÅÑÂ†¥Âêà
                    VStack(spacing: 12) {
                        Image(systemName: "note.text")
                            .font(.system(size: 40))
                            .foregroundColor(.gray)
                        
                        Text("„Éé„Éº„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì")
                            .font(.headline)
                            .foregroundColor(.secondary)
                        
                        Text("Notes„Çø„Éñ„Åß„Éé„Éº„Éà„Çí‰ΩúÊàê„Åó„Å¶„Åã„ÇâÂàÜÊûê„ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .multilineTextAlignment(.center)
                    }
                    .padding(.vertical, 40)
                }
                
                Spacer()
            }
        }
        .navigationTitle("Insights")
    }
    
    // MARK: - Actions
    
    private func performAnalysis() {
        isLoading = true
        
        // ÈùûÂêåÊúü„ÅßÂàÜÊûê„ÇíÂÆüË°å
        DispatchQueue.global(qos: .userInitiated).async {
            let analysis = analyzeNotes()
            
            DispatchQueue.main.async {
                self.emotionAnalysis = analysis.emotions
                self.loopDetection = analysis.loops
                self.biasSignals = analysis.biases
                self.isLoading = false
            }
        }
    }
    
    private func analyzeNotes() -> (emotions: [String: Double], loops: [String], biases: [String]) {
        var emotions: [String: Double] = [:]
        var loops: [String] = []
        var biases: [String] = []
        
        // Á∞°Âçò„Å™ÊÑüÊÉÖÂàÜÊûêÔºà„Çµ„É≥„Éó„É´Ôºâ
        let allText = items.compactMap { $0.note }.joined(separator: " ")
        
        // ÊÑüÊÉÖÂàÜÊûêÔºà„Ç≠„Éº„ÉØ„Éº„Éâ„Éô„Éº„ÇπÔºâ
        let positiveWords = ["Ê•Ω„Åó„ÅÑ", "Â¨â„Åó„ÅÑ", "Âπ∏„Åõ", "ËâØ„ÅÑ", "Á¥†Êô¥„Çâ„Åó„ÅÑ", "ÊúÄÈ´ò"]
        let negativeWords = ["ÊÇ≤„Åó„ÅÑ", "Ëæõ„ÅÑ", "Ëã¶„Åó„ÅÑ", "ÊÇ™„ÅÑ", "ÊúÄÊÇ™", "Â´å„ÅÑ"]
        let neutralWords = ["ÊôÆÈÄö", "„Åæ„ÅÇ„Åæ„ÅÇ", "Áâπ„Å´", "„Å™„Çì„Åß„ÇÇ„Å™„ÅÑ"]
        
        let positiveCount = positiveWords.reduce(0) { count, word in
            count + allText.components(separatedBy: word).count - 1
        }
        let negativeCount = negativeWords.reduce(0) { count, word in
            count + allText.components(separatedBy: word).count - 1
        }
        let neutralCount = neutralWords.reduce(0) { count, word in
            count + allText.components(separatedBy: word).count - 1
        }
        
        let total = positiveCount + negativeCount + neutralCount
        if total > 0 {
            emotions["„Éù„Ç∏„ÉÜ„Ç£„Éñ"] = Double(positiveCount) / Double(total)
            emotions["„Éç„Ç¨„ÉÜ„Ç£„Éñ"] = Double(negativeCount) / Double(total)
            emotions["„Éã„É•„Éº„Éà„É©„É´"] = Double(neutralCount) / Double(total)
        }
        
        // „É´„Éº„ÉóÊ§úÂá∫ÔºàÈáçË§á„ÉÜ„Ç≠„Çπ„ÉàÔºâ
        let uniqueTexts = Set(items.compactMap { $0.note })
        if uniqueTexts.count < items.count {
            loops.append("Âêå„ÅòÂÜÖÂÆπ„ÅÆ„Éé„Éº„Éà„ÅåË§áÊï∞ÂõûË®òÈå≤„Åï„Çå„Å¶„ÅÑ„Åæ„Åô")
        }
        
        // „Éê„Ç§„Ç¢„ÇπÊ§úÂá∫Ôºà„Çµ„É≥„Éó„É´Ôºâ
        if allText.contains("Áµ∂ÂØæ") || allText.contains("ÂøÖ„Åö") {
            biases.append("ÂÖ®„ÅãÁÑ°„ÅãÊÄùËÄÉ„ÅÆÂÖÜÂÄô")
        }
        if allText.contains("„Åø„Çì„Å™") || allText.contains("Ë™∞„Åß„ÇÇ") {
            biases.append("‰∏ÄËà¨Âåñ„ÅÆÈÅéË™§„ÅÆÂÖÜÂÄô")
        }
        
        return (emotions: emotions, loops: loops, biases: biases)
    }
}

// MARK: - Analysis Card

struct AnalysisCard<Content: View>: View {
    let title: String
    let icon: String
    let color: Color
    let content: Content
    
    init(title: String, icon: String, color: Color, @ViewBuilder content: () -> Content) {
        self.title = title
        self.icon = icon
        self.color = color
        self.content = content()
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Image(systemName: icon)
                    .foregroundColor(color)
                Text(title)
                    .font(.headline)
                    .fontWeight(.semibold)
                Spacer()
            }
            
            content
        }
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(12)
    }
}

// MARK: - Settings View

struct SettingsView: View {
    @Environment(\.managedObjectContext) private var viewContext
    @FetchRequest(
        sortDescriptors: [NSSortDescriptor(keyPath: \Item.timestamp, ascending: false)],
        animation: .default
    )
    private var items: FetchedResults<Item>
    
    @State private var showingDeleteAlert = false
    @State private var showingExportAlert = false
    @State private var showingPruningView = false
    // @StateObject private var cloudSyncService = CloudSyncService(persistentContainer: PersistenceController.shared.container, vault: Vault.shared)
    
    var body: some View {
        List {
            // „Ç¢„Éó„É™ÊÉÖÂ†±„Çª„ÇØ„Ç∑„Éß„É≥
            Section {
                HStack {
                    Image(systemName: "brain.head.profile")
                        .font(.system(size: 40))
                        .foregroundColor(.blue)
                        .frame(width: 50, height: 50)
                        .background(Color.blue.opacity(0.1))
                        .cornerRadius(10)
                    
                    VStack(alignment: .leading, spacing: 4) {
                        Text("MetaWave v2.2")
                            .font(.headline)
                            .fontWeight(.semibold)
                        Text("„É°„ÇøË™çÁü•„Éë„Éº„Éà„Éä„Éº")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                        Text("ÊÄùËÄÉ„Å®Ë°åÂãï„ÇíË®òÈå≤„ÉªÂàÜÊûê")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    
                    Spacer()
                }
                .padding(.vertical, 8)
            }
            
            // ÂêåÊúü„Çª„ÇØ„Ç∑„Éß„É≥
            Section("ÂêåÊúü") {
                // SyncStatusView(cloudSyncService: cloudSyncService)
                HStack {
                    Image(systemName: "icloud")
                        .foregroundColor(.blue)
                    Text("„ÇØ„É©„Ç¶„ÉâÂêåÊúü")
                    Spacer()
                    Text("Ê∫ñÂÇô‰∏≠")
                        .foregroundColor(.secondary)
                }
            }
            
            // „Éá„Éº„ÇøÁÆ°ÁêÜ„Çª„ÇØ„Ç∑„Éß„É≥
            Section("„Éá„Éº„ÇøÁÆ°ÁêÜ") {
                HStack {
                    Image(systemName: "doc.text")
                        .foregroundColor(.blue)
                    Text("„Éé„Éº„ÉàÊï∞")
                    Spacer()
                    Text("\(items.count)‰ª∂")
                        .foregroundColor(.secondary)
                }
                
                HStack {
                    Image(systemName: "square.and.arrow.up")
                        .foregroundColor(.green)
                    Text("„Éá„Éº„Çø„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà")
                }
                .onTapGesture {
                    showingExportAlert = true
                }
                
                HStack {
                    Image(systemName: "scissors")
                        .foregroundColor(.orange)
                    Text("Ââ™ÂÆö„Ç¢„Ç∑„Çπ„Çø„É≥„Éà")
                }
                .onTapGesture {
                    showingPruningView = true
                }
                
                HStack {
                    Image(systemName: "trash")
                        .foregroundColor(.red)
                    Text("„Åô„Åπ„Å¶„ÅÆ„Éá„Éº„Çø„ÇíÂâäÈô§")
                }
                .onTapGesture {
                    showingDeleteAlert = true
                }
            }
            
            // „Çª„Ç≠„É•„É™„ÉÜ„Ç£„Çª„ÇØ„Ç∑„Éß„É≥
            Section("„Çª„Ç≠„É•„É™„ÉÜ„Ç£") {
                HStack {
                    Image(systemName: "lock.shield")
                        .foregroundColor(.green)
                    Text("E2EÊöóÂè∑Âåñ")
                    Spacer()
                    Text("ÊúâÂäπ")
                        .foregroundColor(.green)
                        .fontWeight(.semibold)
                }
                
                HStack {
                    Image(systemName: "key")
                        .foregroundColor(.blue)
                    Text("ÊöóÂè∑Âåñ„Ç≠„Éº")
                    Spacer()
                    Text("„Éá„Éê„Ç§„ÇπÂÜÖ‰øùÂ≠ò")
                        .foregroundColor(.secondary)
                }
                
                HStack {
                    Image(systemName: "icloud.slash")
                        .foregroundColor(.orange)
                    Text("„ÇØ„É©„Ç¶„ÉâÂêåÊúü")
                    Spacer()
                    Text("ÁÑ°Âäπ")
                        .foregroundColor(.secondary)
                }
            }
            
            // ÂàÜÊûêË®≠ÂÆö„Çª„ÇØ„Ç∑„Éß„É≥
            Section("ÂàÜÊûêË®≠ÂÆö") {
                HStack {
                    Image(systemName: "brain")
                        .foregroundColor(.purple)
                    Text("ÊÑüÊÉÖÂàÜÊûê")
                    Spacer()
                    Text("ÊúâÂäπ")
                        .foregroundColor(.green)
                        .fontWeight(.semibold)
                }
                
                HStack {
                    Image(systemName: "arrow.clockwise")
                        .foregroundColor(.orange)
                    Text("„É´„Éº„ÉóÊ§úÂá∫")
                    Spacer()
                    Text("ÊúâÂäπ")
                        .foregroundColor(.green)
                        .fontWeight(.semibold)
                }
                
                HStack {
                    Image(systemName: "eye.trianglebadge.exclamationmark")
                        .foregroundColor(.red)
                    Text("„Éê„Ç§„Ç¢„ÇπÊ§úÂá∫")
                    Spacer()
                    Text("ÊúâÂäπ")
                        .foregroundColor(.green)
                        .fontWeight(.semibold)
                }
            }
            
            // „Ç¢„Éó„É™ÊÉÖÂ†±„Çª„ÇØ„Ç∑„Éß„É≥
            Section("„Ç¢„Éó„É™ÊÉÖÂ†±") {
                HStack {
                    Image(systemName: "info.circle")
                        .foregroundColor(.blue)
                    Text("„Éê„Éº„Ç∏„Éß„É≥")
                    Spacer()
                    Text("2.0.0")
                        .foregroundColor(.secondary)
                }
                
                HStack {
                    Image(systemName: "calendar")
                        .foregroundColor(.gray)
                    Text("„É™„É™„Éº„ÇπÊó•")
                    Spacer()
                    Text("2025-10-25")
                        .foregroundColor(.secondary)
                }
                
                HStack {
                    Image(systemName: "person.circle")
                        .foregroundColor(.green)
                    Text("ÈñãÁô∫ËÄÖ")
                    Spacer()
                    Text("Miyabi Workflow")
                        .foregroundColor(.secondary)
                }
            }
        }
        .navigationTitle("Settings")
        .alert("„Éá„Éº„Çø„ÇíÂâäÈô§", isPresented: $showingDeleteAlert) {
            Button("„Ç≠„É£„É≥„Çª„É´", role: .cancel) { }
            Button("ÂâäÈô§", role: .destructive) {
                deleteAllData()
            }
        } message: {
            Text("„Åô„Åπ„Å¶„ÅÆ„Éé„Éº„Éà„Å®„Éá„Éº„Çø„ÅåÂâäÈô§„Åï„Çå„Åæ„Åô„ÄÇ„Åì„ÅÆÊìç‰Ωú„ÅØÂèñ„ÇäÊ∂à„Åõ„Åæ„Åõ„Çì„ÄÇ")
        }
        .alert("„Éá„Éº„Çø„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà", isPresented: $showingExportAlert) {
            Button("OK") { }
        } message: {
            Text("„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÊ©üËÉΩ„ÅØÊ∫ñÂÇô‰∏≠„Åß„Åô„ÄÇ")
        }
        .sheet(isPresented: $showingPruningView) {
            PruningView()
        }
    }
    
    // MARK: - Actions
    
    private func deleteAllData() {
        withAnimation {
            items.forEach { item in
                viewContext.delete(item)
            }
            
            do {
                try viewContext.save()
            } catch {
                print("[CoreData] Delete all error:", error.localizedDescription)
            }
        }
    }
}

// MARK: - Pruning View

struct PruningView: View {
    @Environment(\.managedObjectContext) private var viewContext
    @Environment(\.dismiss) private var dismiss
    @FetchRequest(
        sortDescriptors: [NSSortDescriptor(keyPath: \Item.timestamp, ascending: false)],
        animation: .default
    )
    private var items: FetchedResults<Item>
    
    @State private var pruningCandidates: [PruningCandidate] = []
    @State private var isLoading = false
    @State private var showingDeleteAlert = false
    @State private var selectedCandidate: PruningCandidate?
    
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                // „Éò„ÉÉ„ÉÄ„Éº
                VStack(spacing: 8) {
                    Image(systemName: "scissors")
                        .font(.system(size: 60))
                        .foregroundColor(.orange)
                    
                    Text("Ââ™ÂÆö„Ç¢„Ç∑„Çπ„Çø„É≥„Éà")
                        .font(.title2)
                        .fontWeight(.semibold)
                    
                    Text("‰∏çË¶Å„Å™„Éé„Éº„Éà„ÇíÊï¥ÁêÜ„Åó„Åæ„Åó„Çá„ÅÜ")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                }
                .padding(.top, 20)
                
                // ÂàÜÊûê„Éú„Çø„É≥
                Button(action: analyzePruningCandidates) {
                    HStack {
                        if isLoading {
                            ProgressView()
                                .scaleEffect(0.8)
                        } else {
                            Image(systemName: "magnifyingglass")
                        }
                        Text(isLoading ? "ÂàÜÊûê‰∏≠..." : "Ââ™ÂÆöÂÄôË£ú„ÇíÂàÜÊûê")
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.orange)
                    .foregroundColor(.white)
                    .cornerRadius(10)
                }
                .disabled(isLoading || items.isEmpty)
                .padding(.horizontal)
                
                // Ââ™ÂÆöÂÄôË£ú„É™„Çπ„Éà
                if !pruningCandidates.isEmpty {
                    ScrollView {
                        LazyVStack(spacing: 12) {
                            ForEach(pruningCandidates, id: \.id) { candidate in
                                PruningCandidateCard(candidate: candidate) {
                                    selectedCandidate = candidate
                                    showingDeleteAlert = true
                                }
                            }
                        }
                        .padding(.horizontal)
                    }
                } else if !isLoading && !items.isEmpty {
                    // Ââ™ÂÆöÂÄôË£ú„Åå„Å™„ÅÑÂ†¥Âêà
                    VStack(spacing: 12) {
                        Image(systemName: "checkmark.circle")
                            .font(.system(size: 40))
                            .foregroundColor(.green)
                        
                        Text("Ââ™ÂÆöÂÄôË£ú„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì")
                            .font(.headline)
                            .foregroundColor(.secondary)
                        
                        Text("„Åô„Åπ„Å¶„ÅÆ„Éé„Éº„Éà„ÅåÊúâÁî®„Åß„Åô")
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .multilineTextAlignment(.center)
                    }
                    .padding(.vertical, 40)
                } else if items.isEmpty {
                    // „Éé„Éº„Éà„Åå„Å™„ÅÑÂ†¥Âêà
                    VStack(spacing: 12) {
                        Image(systemName: "note.text")
                            .font(.system(size: 40))
                            .foregroundColor(.gray)
                        
                        Text("„Éé„Éº„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì")
                            .font(.headline)
                            .foregroundColor(.secondary)
                        
                        Text("Notes„Çø„Éñ„Åß„Éé„Éº„Éà„Çí‰ΩúÊàê„Åó„Å¶„Åã„ÇâÂâ™ÂÆö„ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .multilineTextAlignment(.center)
                    }
                    .padding(.vertical, 40)
                }
                
                Spacer()
            }
            .navigationTitle("Ââ™ÂÆö„Ç¢„Ç∑„Çπ„Çø„É≥„Éà")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Èñâ„Åò„Çã") {
                        dismiss()
                    }
                }
            }
        }
        .alert("„Éé„Éº„Éà„ÇíÂâäÈô§", isPresented: $showingDeleteAlert) {
            Button("„Ç≠„É£„É≥„Çª„É´", role: .cancel) { }
            Button("ÂâäÈô§", role: .destructive) {
                if let candidate = selectedCandidate {
                    deletePruningCandidate(candidate)
                }
            }
        } message: {
            if let candidate = selectedCandidate {
                Text("„Äå\(candidate.title)„Äç„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü„Åì„ÅÆÊìç‰Ωú„ÅØÂèñ„ÇäÊ∂à„Åõ„Åæ„Åõ„Çì„ÄÇ")
            }
        }
    }
    
    // MARK: - Actions
    
    private func analyzePruningCandidates() {
        isLoading = true
        
        DispatchQueue.global(qos: .userInitiated).async {
            let candidates = findPruningCandidates()
            
            DispatchQueue.main.async {
                self.pruningCandidates = candidates
                self.isLoading = false
            }
        }
    }
    
    private func findPruningCandidates() -> [PruningCandidate] {
        var candidates: [PruningCandidate] = []
        
        // Âè§„ÅÑ„Éé„Éº„ÉàÔºà30Êó•‰ª•‰∏äÂâçÔºâ
        let thirtyDaysAgo = Calendar.current.date(byAdding: .day, value: -30, to: Date()) ?? Date()
        let oldItems = items.filter { item in
            guard let timestamp = item.timestamp else { return false }
            return timestamp < thirtyDaysAgo
        }
        
        for item in oldItems {
            candidates.append(PruningCandidate(
                id: item.objectID,
                title: item.title ?? "Untitled",
                note: item.note ?? "",
                timestamp: item.timestamp ?? Date(),
                reason: "30Êó•‰ª•‰∏äÂâç„ÅÆÂè§„ÅÑ„Éé„Éº„Éà",
                priority: .medium
            ))
        }
        
        // Áü≠„ÅÑ„Éé„Éº„ÉàÔºà10ÊñáÂ≠ó‰ª•‰∏ãÔºâ
        let shortItems = items.filter { item in
            guard let note = item.note else { return false }
            return note.count <= 10
        }
        
        for item in shortItems {
            candidates.append(PruningCandidate(
                id: item.objectID,
                title: item.title ?? "Untitled",
                note: item.note ?? "",
                timestamp: item.timestamp ?? Date(),
                reason: "Áü≠„ÅÑ„Éé„Éº„ÉàÔºà10ÊñáÂ≠ó‰ª•‰∏ãÔºâ",
                priority: .low
            ))
        }
        
        // ÈáçË§á„Éé„Éº„Éà
        let noteTexts = items.compactMap { $0.note }
        let uniqueTexts = Set(noteTexts)
        
        if noteTexts.count != uniqueTexts.count {
            // ÈáçË§á„ÇíÊ§úÂá∫
            var textCounts: [String: Int] = [:]
            for text in noteTexts {
                textCounts[text, default: 0] += 1
            }
            
            for (text, count) in textCounts {
                if count > 1 {
                    let duplicateItems = items.filter { $0.note == text }
                    for item in duplicateItems.dropFirst() { // ÊúÄÂàù„ÅÆ1„Å§‰ª•Â§ñ
                        candidates.append(PruningCandidate(
                            id: item.objectID,
                            title: item.title ?? "Untitled",
                            note: item.note ?? "",
                            timestamp: item.timestamp ?? Date(),
                            reason: "ÈáçË§á„Éé„Éº„Éà",
                            priority: .high
                        ))
                    }
                }
            }
        }
        
        // ÂÑ™ÂÖàÂ∫¶È†Ü„Å´„ÇΩ„Éº„Éà
        return candidates.sorted { $0.priority.rawValue > $1.priority.rawValue }
    }
    
    private func deletePruningCandidate(_ candidate: PruningCandidate) {
        withAnimation {
            if let item = items.first(where: { $0.objectID == candidate.id }) {
                viewContext.delete(item)
                
                do {
                    try viewContext.save()
                    // ÂÄôË£ú„É™„Çπ„Éà„Åã„Çâ„ÇÇÂâäÈô§
                    pruningCandidates.removeAll { $0.id == candidate.id }
                } catch {
                    print("[CoreData] Delete pruning candidate error:", error.localizedDescription)
                }
            }
        }
    }
}

// MARK: - Pruning Candidate

struct PruningCandidate {
    let id: NSManagedObjectID
    let title: String
    let note: String
    let timestamp: Date
    let reason: String
    let priority: Priority
    
    enum Priority: Int, CaseIterable {
        case low = 1
        case medium = 2
        case high = 3
        
        var color: Color {
            switch self {
            case .low: return .green
            case .medium: return .orange
            case .high: return .red
            }
        }
        
        var text: String {
            switch self {
            case .low: return "‰Ωé"
            case .medium: return "‰∏≠"
            case .high: return "È´ò"
            }
        }
    }
}

// MARK: - Pruning Candidate Card

struct PruningCandidateCard: View {
    let candidate: PruningCandidate
    let onDelete: () -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(candidate.title)
                        .font(.headline)
                        .fontWeight(.semibold)
                    
                    Text(candidate.timestamp, formatter: itemFormatter)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                VStack(alignment: .trailing, spacing: 4) {
                    Text(candidate.priority.text)
                        .font(.caption)
                        .fontWeight(.semibold)
                        .foregroundColor(.white)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 4)
                        .background(candidate.priority.color)
                        .cornerRadius(8)
                    
                    Text(candidate.reason)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            
            if !candidate.note.isEmpty {
                Text(candidate.note)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                    .lineLimit(3)
            }
            
            HStack {
                Spacer()
                Button("ÂâäÈô§") {
                    onDelete()
                }
                .buttonStyle(.bordered)
                .controlSize(.small)
                .foregroundColor(.red)
            }
        }
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(12)
    }
}

// MARK: - Formatter

private let itemFormatter: DateFormatter = {
    let formatter = DateFormatter()
    formatter.dateStyle = .short
    formatter.timeStyle = .medium
    return formatter
}()

// MARK: - Preview

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView().environment(\.managedObjectContext, PersistenceController.preview.container.viewContext)
    }
}